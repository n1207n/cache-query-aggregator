package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/n1207n/cache-query-aggregator/config"
	"github.com/n1207n/cache-query-aggregator/db/sqlc"
	"github.com/n1207n/cache-query-aggregator/internal/util"
)

const (
	totalUsers            = 100
	totalPosts            = 2_000_000
	postsPerBatch         = 50_000
	skewFactor            = 1.1
	skewDistributionRange = 10
	randomStrBytes        = 25
)

func main() {
	ctx := context.Background()

	log.Println("Loading config...")
	cfg, err := config.LoadConfig()
	if err != nil {
		log.Fatalf("Error loading config: %v", err)
	}

	log.Println("Connecting to database...")
	dbpool, err := initDB(cfg.DbURL)
	if err != nil {
		log.Fatalf("Error connecting to database: %v", err)
	}
	defer dbpool.Close()

	queries := sqlc.New(dbpool)

	log.Printf("Creating %d users...", totalUsers)
	users, err := createUsers(ctx, queries, totalUsers)
	if err != nil {
		log.Fatalf("Error creating users: %v", err)
	}
	log.Printf("Successfully created %d users", len(users))

	log.Printf("Creating %d posts with skewed user distribution range", totalPosts)
	if err := createPostsInBatches(ctx, dbpool, users, totalPosts); err != nil {
		log.Fatalf("Error creating posts: %v", err)
	}
	log.Printf("Successfully created %d posts", totalPosts)
}

func createPostsInBatches(ctx context.Context, dbpool *pgxpool.Pool, users []sqlc.User, count int) error {
	zipf := rand.NewZipf(rand.New(rand.NewSource(time.Now().UnixNano())), skewFactor, skewDistributionRange, uint64(len(users)-1))
	userIds := make([]int64, len(users))

	for i, u := range users {
		userIds[i] = u.ID
	}

	q := sqlc.New(dbpool)
	for i := 0; i < count; i += postsPerBatch {
		end := i + postsPerBatch
		if end > count {
			end = count
		}

		batchSize := end - i
		log.Printf("Creating batch of %d posts (%d/%d)", batchSize, end, count)

		params := make([]sqlc.CreatePostsInBatchParams, batchSize)
		for j := 0; j < batchSize; j++ {
			userId := userIds[zipf.Uint64()]
			params[j] = sqlc.CreatePostsInBatchParams{
				UserID:  userId,
				Content: fmt.Sprintf("This is post content %d generated by datagen. UserId is %d. Random data: %s", i+j+1, userId, util.RandomString(randomStrBytes)),
			}
		}

		rowsAffected, err := q.CreatePostsInBatch(ctx, params)
		if err != nil {
			return fmt.Errorf("batch %d-%d failed: %w", i, end, err)
		}
		if rowsAffected != int64(batchSize) {
			return fmt.Errorf("expected %d rows to be affected, but got %d", batchSize, rowsAffected)
		}
	}

	return nil
}

func createUsers(ctx context.Context, queries *sqlc.Queries, count int) ([]sqlc.User, error) {
	users := make([]sqlc.User, 0, count)
	for i := 0; i < count; i++ {
		hashedPassword, err := util.HashPassword("password123")
		if err != nil {
			return nil, err
		}

		params := sqlc.CreateUserParams{
			FirstName:      "Test",
			LastName:       fmt.Sprintf("User %s", util.RandomString(5)),
			Email:          fmt.Sprintf("testuser_%s@example.com", util.RandomString(10)),
			HashedPassword: hashedPassword,
		}

		user, err := queries.CreateUser(ctx, params)
		if err != nil {
			log.Printf("Error creating user with email %s: %v. Retrying.", params.Email, err)
			i--
			continue
		}

		users = append(users, user)
	}

	return users, nil
}

func initDB(dbURL string) (*pgxpool.Pool, error) {
	dbConfig, err := pgxpool.ParseConfig(dbURL)
	if err != nil {
		return nil, fmt.Errorf("error parsing database URL: %w", err)
	}

	pool, err := pgxpool.NewWithConfig(context.Background(), dbConfig)
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := pool.Ping(ctx); err != nil {
		return nil, fmt.Errorf("error pinging database: %w", err)
	}

	return pool, nil
}
